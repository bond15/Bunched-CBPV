@article{o'hearn_2003, title={On bunched typing}, volume={13}, DOI={10.1017/S0956796802004495}, number={4}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={O'HEARN, PETER}, year={2003}, pages={747–796}}

@misc{Max-CT-W23,
    title = "https://leccap.engin.umich.edu/leccap/site/z02eb2esrpaddy7cnwz"
}

@misc{CBPV-Book,
    title= "https://link-springer-com.proxy.lib.umich.edu/book/10.1007/978-94-007-0954-6#book-header"
}
@article{JACOBS199473,
title = {Semantics of weakening and contraction},
journal = {Annals of Pure and Applied Logic},
volume = {69},
number = {1},
pages = {73-106},
year = {1994},
issn = {0168-0072},
doi = {https://doi.org/10.1016/0168-0072(94)90020-5},
url = {https://www.sciencedirect.com/science/article/pii/0168007294900205},
author = {Bart Jacobs},
abstract = {The shriek modality \s! of linear logic performs two tasks: it restores in annotated from both weakening and contraction. We separate these tasks by introducing two modalities: !w for weakening and !c for contraction. These give rise to two logics which are “inbetween” linear and intuitionistic logic: in affine (or weakening) logic one always has a weakening and a !w for contraction and in relevant (or contraction) logic one always has a contraction and a !w weakening. The semantics of these logics is obtained from special kinds of monads, introduced by Anders Kock in the early seventies. As subtle point is how to retrieve the \s! of linear logic from !w and !c. Technically this will be achieved in terms of distributive laws—introduced by Jon Beck. We find models where one has \s! = !w!c and also models with \s! = !c!w. It will be shown that on the category of complete lattices one has comonads !w and !c with !w!c = \s!= !c!w.}
}

@misc{Semantics-Proof-Theory-Bunched-Implications,
    title="https://link.springer.com/content/pdf/10.1007/978-94-017-0091-7.pdf"

}
@misc{nlabDayConv,
    title = "https://ncatlab.org/nlab/show/Day+convolution#Day70Thesis" 
}
@book{pym_semantics_2002,
	address = {Dordrecht},
	series = {Applied {Logic} {Series}},
	title = {The {Semantics} and {Proof} {Theory} of the {Logic} of {Bunched} {Implications}},
	volume = {26},
	isbn = {978-90-481-6072-3 978-94-017-0091-7},
	url = {http://link.springer.com/10.1007/978-94-017-0091-7},
	urldate = {2024-03-18},
	publisher = {Springer Netherlands},
	author = {Pym, David J.},
	editor = {Gabbay, Dov M. and Barwise, Jon},
	year = {2002},
	doi = {10.1007/978-94-017-0091-7},
	keywords = {calculus, logic, mathematical logic, model theory, proof, proof theory, sequent calculus, type theory},
	file = {Full Text PDF:/home/ericbond/Zotero/storage/VEL43FQ4/Pym - 2002 - The Semantics and Proof Theory of the Logic of Bun.pdf:application/pdf},
}

@article{ohearn_bunched_2003,
	title = {On bunched typing},
	volume = {13},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796802004495/type/journal_article},
	doi = {10.1017/S0956796802004495},
	abstract = {We study a typing scheme derived from a semantic situation where a single category possesses several closed structures, corresponding to diﬀerent varieties of function type. In this scheme typing contexts are trees built from two (or more) binary combining operations, or in short, bunches. Bunched typing and its logical counterpart, bunched implications, have arisen in joint work of the author and David Pym. The present paper gives a basic account of the type system, and then focusses on concrete models that illustrate how it may be understood in terms of resource access and sharing. The most basic system has two context-combining operations, and the structural rules of Weakening and Contraction are allowed for one but not the other. This system includes a multiplicative, or substructural, function type −* alongside the usual (additive) function type →; it is dubbed the αλ-calculus after its binders, α for the αdditive binder and λ for the multiplicative, or λinear, binder. We show that the features of this system are, in a sense, complementary to calculi based on linear logic; it is incompatible with an interpretation where a multiplicative function uses its argument once, but perfectly compatible with a reading based on sharing of resources. This sharing interpretation is derived from syntactic control of interference, a type-theoretic method of controlling sharing of storage, and we show how bunch-based management of Contraction can be used to provide a more ﬂexible type system for interference control.},
	language = {en},
	number = {4},
	urldate = {2024-02-17},
	journal = {Journal of Functional Programming},
	author = {O'Hearn, Peter},
	month = jul,
	year = {2003},
	pages = {747--796},
	file = {O'Hearn - 2003 - On bunched typing.pdf:/home/ericbond/Zotero/storage/VQ9S938P/O'Hearn - 2003 - On bunched typing.pdf:application/pdf},
}

@inproceedings{forster_call-by-push-value_2019,
	address = {Cascais Portugal},
	title = {Call-by-push-value in {Coq}: operational, equational, and denotational theory},
	isbn = {978-1-4503-6222-1},
	shorttitle = {Call-by-push-value in {Coq}},
	url = {https://dl.acm.org/doi/10.1145/3293880.3294097},
	doi = {10.1145/3293880.3294097},
	abstract = {Call-by-push-value (CBPV) is an idealised calculus for functional and imperative programming, introduced as a subsuming paradigm for both call-by-value (CBV) and call-by-name (CBN). We formalise weak and strong operational semantics for (effect-free) CBPV, define its equational theory, and verify adequacy for the standard set/algebra denotational semantics. Furthermore, we prove normalisation of the standard reduction, confluence of strong reduction, strong normalisation using Kripke logical relations, and soundness of the equational theory using logical equivalence. We adapt and verify the known translations from CBV and CBN into CBPV for strong reduction. This yields, for instance, proofs of strong normalisation and confluence for the full λ-calculus with sums and products. Thanks to the automation provided by Coq and the Autosubst 2 framework, there is little formalisation overhead compared to detailed paper proofs.},
	language = {en},
	urldate = {2024-03-01},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Conference} on {Certified} {Programs} and {Proofs}},
	publisher = {ACM},
	author = {Forster, Yannick and Schäfer, Steven and Spies, Simon and Stark, Kathrin},
	month = jan,
	year = {2019},
	pages = {118--131},
	file = {Forster et al. - 2019 - Call-by-push-value in Coq operational, equational.pdf:/home/ericbond/Zotero/storage/Z6JPI437/Forster et al. - 2019 - Call-by-push-value in Coq operational, equational.pdf:application/pdf},
}


@misc{sterling_denotational_2023,
	title = {Denotational semantics of general store and polymorphism},
	url = {http://arxiv.org/abs/2210.02169},
	abstract = {We contribute the ﬁrst denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on recursively deﬁned semantic worlds, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the logical relations as types principle, in which equivalences between imperative abstract datatypes can be established synthetically. What is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically deﬁnable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of synthetic guarded domain theory.},
	language = {en},
	urldate = {2024-02-29},
	publisher = {arXiv},
	author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
	month = apr,
	year = {2023},
	note = {arXiv:2210.02169 [cs]},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	file = {Sterling et al. - 2023 - Denotational semantics of general store and polymo.pdf:/home/ericbond/Zotero/storage/4WJQLXXI/Sterling et al. - 2023 - Denotational semantics of general store and polymo.pdf:application/pdf},
}


