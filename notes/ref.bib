@article{o'hearn_2003, title={On bunched typing}, volume={13}, DOI={10.1017/S0956796802004495}, number={4}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={O'HEARN, PETER}, year={2003}, pages={747–796}}

@misc{Max-CT-W23,
    title = "https://leccap.engin.umich.edu/leccap/site/z02eb2esrpaddy7cnwz"
}

@misc{CBPV-Book,
    title= "https://link-springer-com.proxy.lib.umich.edu/book/10.1007/978-94-007-0954-6#book-header"
}
@article{JACOBS199473,
title = {Semantics of weakening and contraction},
journal = {Annals of Pure and Applied Logic},
volume = {69},
number = {1},
pages = {73-106},
year = {1994},
issn = {0168-0072},
doi = {https://doi.org/10.1016/0168-0072(94)90020-5},
url = {https://www.sciencedirect.com/science/article/pii/0168007294900205},
author = {Bart Jacobs},
abstract = {The shriek modality \s! of linear logic performs two tasks: it restores in annotated from both weakening and contraction. We separate these tasks by introducing two modalities: !w for weakening and !c for contraction. These give rise to two logics which are “inbetween” linear and intuitionistic logic: in affine (or weakening) logic one always has a weakening and a !w for contraction and in relevant (or contraction) logic one always has a contraction and a !w weakening. The semantics of these logics is obtained from special kinds of monads, introduced by Anders Kock in the early seventies. As subtle point is how to retrieve the \s! of linear logic from !w and !c. Technically this will be achieved in terms of distributive laws—introduced by Jon Beck. We find models where one has \s! = !w!c and also models with \s! = !c!w. It will be shown that on the category of complete lattices one has comonads !w and !c with !w!c = \s!= !c!w.}
}

@misc{Semantics-Proof-Theory-Bunched-Implications,
    title="https://link.springer.com/content/pdf/10.1007/978-94-017-0091-7.pdf"

}

@incollection{ohearnResourceInterpretationsBunched1999,
  title = {Resource {{Interpretations}}, {{Bunched Implications}} and the {$A\lambda$}-{{Calculus}} ({{Preliminary Version}})},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  author = {O'Hearn, Peter W.},
  editor = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan and Girard, Jean-Yves},
  year = {1999},
  volume = {1581},
  pages = {258--279},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  doi = {10.1007/3-540-48959-2_19},
  urldate = {2024-06-08},
  isbn = {978-3-540-65763-7 978-3-540-48959-7},
  langid = {english},
  file = {/home/ericbond/Zotero/storage/6RMV8UHY/O’Hearn - 1999 - Resource Interpretations, Bunched Implications and.pdf}
}

@misc{SE-FinSetMonoCoprod,
  	title = "https://math.stackexchange.com/questions/4797353/does-the-category-of-finite-sets-and-injective-functions-i-e-monomorphisms-h"
}
@misc{nlabDayConv,
    title = "https://ncatlab.org/nlab/show/Day+convolution#Day70Thesis" 
}
@book{pym_semantics_2002,
	address = {Dordrecht},
	series = {Applied {Logic} {Series}},
	title = {The {Semantics} and {Proof} {Theory} of the {Logic} of {Bunched} {Implications}},
	volume = {26},
	isbn = {978-90-481-6072-3 978-94-017-0091-7},
	url = {http://link.springer.com/10.1007/978-94-017-0091-7},
	urldate = {2024-03-18},
	publisher = {Springer Netherlands},
	author = {Pym, David J.},
	editor = {Gabbay, Dov M. and Barwise, Jon},
	year = {2002},
	doi = {10.1007/978-94-017-0091-7},
	keywords = {calculus, logic, mathematical logic, model theory, proof, proof theory, sequent calculus, type theory},
	file = {Full Text PDF:/home/ericbond/Zotero/storage/VEL43FQ4/Pym - 2002 - The Semantics and Proof Theory of the Logic of Bun.pdf:application/pdf},
}

@article{gabbayNewApproachAbstract2002,
  title = {A {{New Approach}} to {{Abstract Syntax}} with {{Variable Binding}}},
  author = {Gabbay, Murdoch J. and Pitts, Andrew M.},
  year = {2002},
  month = jul,
  journal = {Formal Aspects of Computing},
  volume = {13},
  number = {3-5},
  pages = {341--363},
  issn = {0934-5043, 1433-299X},
  doi = {10.1007/s001650200016},
  urldate = {2024-06-05},
  abstract = {The permutation model of set theory with atoms (FM-sets), devised by Fraenkel and Mostowski in the 1930s, supports notions of `name-abstraction' and `fresh name' that provide a new way to represent, compute with, and reason about the syntax of formal systems involving variable-binding operations. Inductively defined FM-sets involving the name-abstraction set former (together with Cartesian product and disjoint union) can correctly encode syntax modulo renaming of bound variables. In this way, the standard theory of algebraic data types can be extended to encompass signatures involving binding operators. In particular, there is an associated notion of structural recursion for defining syntax-manipulating functions (such as capture avoiding substitution, set of free variables, etc.) and a notion of proof by structural induction, both of which remain pleasingly close to informal practice in computer science.},
  copyright = {http://www.springer.com/tdm},
  langid = {english},
  file = {/home/ericbond/Zotero/storage/KMHFDVJY/Gabbay and Pitts - 2002 - A New Approach to Abstract Syntax with Variable Bi.pdf}
}

@article{ohearn_bunched_2003,
	title = {On bunched typing},
	volume = {13},
	issn = {0956-7968, 1469-7653},
	url = {https://www.cambridge.org/core/product/identifier/S0956796802004495/type/journal_article},
	doi = {10.1017/S0956796802004495},
	abstract = {We study a typing scheme derived from a semantic situation where a single category possesses several closed structures, corresponding to diﬀerent varieties of function type. In this scheme typing contexts are trees built from two (or more) binary combining operations, or in short, bunches. Bunched typing and its logical counterpart, bunched implications, have arisen in joint work of the author and David Pym. The present paper gives a basic account of the type system, and then focusses on concrete models that illustrate how it may be understood in terms of resource access and sharing. The most basic system has two context-combining operations, and the structural rules of Weakening and Contraction are allowed for one but not the other. This system includes a multiplicative, or substructural, function type −* alongside the usual (additive) function type →; it is dubbed the αλ-calculus after its binders, α for the αdditive binder and λ for the multiplicative, or λinear, binder. We show that the features of this system are, in a sense, complementary to calculi based on linear logic; it is incompatible with an interpretation where a multiplicative function uses its argument once, but perfectly compatible with a reading based on sharing of resources. This sharing interpretation is derived from syntactic control of interference, a type-theoretic method of controlling sharing of storage, and we show how bunch-based management of Contraction can be used to provide a more ﬂexible type system for interference control.},
	language = {en},
	number = {4},
	urldate = {2024-02-17},
	journal = {Journal of Functional Programming},
	author = {O'Hearn, Peter},
	month = jul,
	year = {2003},
	pages = {747--796},
	file = {O'Hearn - 2003 - On bunched typing.pdf:/home/ericbond/Zotero/storage/VQ9S938P/O'Hearn - 2003 - On bunched typing.pdf:application/pdf},
}

@inproceedings{forster_call-by-push-value_2019,
	address = {Cascais Portugal},
	title = {Call-by-push-value in {Coq}: operational, equational, and denotational theory},
	isbn = {978-1-4503-6222-1},
	shorttitle = {Call-by-push-value in {Coq}},
	url = {https://dl.acm.org/doi/10.1145/3293880.3294097},
	doi = {10.1145/3293880.3294097},
	abstract = {Call-by-push-value (CBPV) is an idealised calculus for functional and imperative programming, introduced as a subsuming paradigm for both call-by-value (CBV) and call-by-name (CBN). We formalise weak and strong operational semantics for (effect-free) CBPV, define its equational theory, and verify adequacy for the standard set/algebra denotational semantics. Furthermore, we prove normalisation of the standard reduction, confluence of strong reduction, strong normalisation using Kripke logical relations, and soundness of the equational theory using logical equivalence. We adapt and verify the known translations from CBV and CBN into CBPV for strong reduction. This yields, for instance, proofs of strong normalisation and confluence for the full λ-calculus with sums and products. Thanks to the automation provided by Coq and the Autosubst 2 framework, there is little formalisation overhead compared to detailed paper proofs.},
	language = {en},
	urldate = {2024-03-01},
	booktitle = {Proceedings of the 8th {ACM} {SIGPLAN} {International} {Conference} on {Certified} {Programs} and {Proofs}},
	publisher = {ACM},
	author = {Forster, Yannick and Schäfer, Steven and Spies, Simon and Stark, Kathrin},
	month = jan,
	year = {2019},
	pages = {118--131},
	file = {Forster et al. - 2019 - Call-by-push-value in Coq operational, equational.pdf:/home/ericbond/Zotero/storage/Z6JPI437/Forster et al. - 2019 - Call-by-push-value in Coq operational, equational.pdf:application/pdf},
}

@article{sterlingFreeTheoremsUnivalent,
  title = {Free Theorems from Univalent Reference Types: {{The}} Impact of Univalence on Denotational Semantics},
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  abstract = {We develop a denotational semantics for general reference types in an impredicative version of guarded homotopy type theory, an adaptation of synthetic guarded domain theory to Voevodsky's univalent foundations. We observe for the first time the profound impact of univalence on the denotational semantics of mutable state. Univalence automatically ensures that all computations are invariant under symmetries of the heap---a bountiful source of free theorems. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.},
  langid = {english},
  file = {/home/ericbond/Zotero/storage/96U93EW7/Sterling et al. - Free theorems from univalent reference types The .pdf}
}

@misc{sterling_denotational_2023,
	title = {Denotational semantics of general store and polymorphism},
	url = {http://arxiv.org/abs/2210.02169},
	abstract = {We contribute the ﬁrst denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on recursively deﬁned semantic worlds, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the logical relations as types principle, in which equivalences between imperative abstract datatypes can be established synthetically. What is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically deﬁnable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of synthetic guarded domain theory.},
	language = {en},
	urldate = {2024-02-29},
	publisher = {arXiv},
	author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
	month = apr,
	year = {2023},
	note = {arXiv:2210.02169 [cs]},
	keywords = {Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	file = {Sterling et al. - 2023 - Denotational semantics of general store and polymo.pdf:/home/ericbond/Zotero/storage/4WJQLXXI/Sterling et al. - 2023 - Denotational semantics of general store and polymo.pdf:application/pdf},
}
@InProceedings{stark:namerp-tlca,
  author = 	 {Ian Stark},
  title = 	 {Names, Equations, Relations: Practical 
  		  Ways to Reason about {\em new}},
  booktitle = 	 {Typed Lambda Calculi and Applications:
  		  Proceedings of the Third International
		  Conference TLCA~'97},
  series =	 {Lecture Notes in Computer Science},
  number =	 1210,
  pages =	 {336--353},
  publisher =	 {Springer-Verlag},
  year = 	 1997,
  note =	 {A full version appears as \cite{stark:namerp-fi}},
  url =		 {http://www.inf.ed.ac.uk/~stark/namerp-tlca.html}
}

@article{starkCategoricalModelsLocal1996,
  title = {Categorical Models for Local Names},
  author = {Stark, Ian},
  year = {1996},
  month = feb,
  journal = {Lisp and Symbolic Computation},
  volume = {9},
  number = {1},
  pages = {77--107},
  issn = {0892-4635, 1573-0557},
  doi = {10.1007/BF01806033},
  urldate = {2024-05-09},
  abstract = {This paper describes the construction of categorical models for the nu-calculus, a language that combines higher-order functions with dynamically created names. Names are created with local scope, they can be compared with each other and passed around through function application, but that is all.},
  copyright = {http://www.springer.com/tdm},
  langid = {english},
  file = {/home/ericbond/Zotero/storage/XTZBP8JM/Stark - 1996 - Categorical models for local names.pdf}
}

@article{SIMPSON-Independence,
title = {Category-theoretic Structure for Independence and Conditional Independence},
journal = {Electronic Notes in Theoretical Computer Science},
volume = {336},
pages = {281-297},
year = {2018},
note = {The Thirty-third Conference on the Mathematical Foundations of Programming Semantics (MFPS XXXIII)},
issn = {1571-0661},
doi = {https://doi.org/10.1016/j.entcs.2018.03.028},
url = {https://www.sciencedirect.com/science/article/pii/S1571066118300318},
author = {Alex Simpson},
keywords = {Independence, conditional independence, probability theory, database theory, nominal sets, separation logic, category theory, fibrations},
abstract = {Relations of independence and conditional independence arise in a variety of contexts. Stochastic independence and conditional independence are fundamental relations in probability theory and statistics. Analogous non-stochastic relations arise in database theory; in the setting of nominal sets (a semantic framework for modelling data with names); and in the modelling of concepts such as region disjointness for heap memory. In this paper, we identify unifying category-theoretic structure that encompasses these different forms of independence and conditional independence. The proposed structure supports the expected reasoning principles for notions of independence and conditional independence. We further identify associated notions of independent and local independent product, in which (conditional) independence is represented via a (fibred) monoidal structure, which is present in many examples.}
}