-- {-# OPTIONS --lossy-unification #-}
module src.Data.BiDCC where 
    open import Cubical.Foundations.HLevels hiding (extend)
    open import Cubical.Foundations.Prelude  
    open import Cubical.Categories.Category
    open import Cubical.Categories.Functor
    open import Cubical.Categories.Instances.Functors
    open import Cubical.Categories.Instances.Sets
    open import Cubical.Categories.NaturalTransformation
    open import Cubical.Categories.Functors.Constant
    open import Cubical.Categories.Presheaf.Base
    open import Cubical.Categories.Presheaf.Constructions
    open import Cubical.Categories.Bifunctor.Redundant hiding (Fst)
    open import Cubical.Categories.Monoidal.Base
    open import src.Data.DayConv
    open import Cubical.Foundations.Isomorphism
    open import Cubical.Data.Sigma 
    open import Cubical.HITs.SetCoequalizer
    open import src.Data.Coend
    open import Cubical.Categories.Constructions.BinProduct renaming (_√óC_ to _B√óC_)
    open import src.Data.PresheafCCC
    open import Cubical.Categories.Yoneda.More
    open import Cubical.Foundations.Function
    open import Cubical.Data.Sigma 


    module Mod {‚Ñì ‚Ñì' : Level}(SMC : StrictMonCategory ‚Ñì ‚Ñì') where 
        ‚Ñìm = (‚Ñì-max ‚Ñì ‚Ñì')
        open Category
        open Functor
        open Bifunctor
        open NatTrans
        open StrictMonStr hiding(_‚äó_ ; _‚äó‚Çï_)
        open TensorStr hiding(_‚äó_ ; _‚äó‚Çï_)
        open Iso        
        open SetCoequalizer 
        open UniversalProperty
        open Bifunctor
        open Coend
        open Cowedge
        open StrictMonCategory SMC renaming(‚îÄ‚äó‚îÄ to ‚®Çc)
        
        ùì• : Category (‚Ñì-suc ‚Ñìm) ‚Ñìm 
        ùì• = PresheafCategory C ‚Ñìm 

        _‚®Ç·¥∞_ : ob ùì• ‚Üí ob ùì• ‚Üí ob ùì•
        A ‚®Ç·¥∞ B =  _‚äó·¥∞_  {MC = SMC} A B


        open import Cubical.Categories.Constructions.BinProduct.Redundant.Base renaming (_√óC_ to _R√óC_)
    
        ùì•√ó : Category (‚Ñì-suc ‚Ñìm) ‚Ñìm
        ùì•√ó = PresheafCategory (C B√óC C)‚Ñìm

        open import Cubical.Categories.Instances.Sets.Properties
        open import Cubical.Categories.Limits.BinProduct.More
        open import Cubical.Categories.Limits.BinProduct

        SetBP : BinProducts (SET ‚Ñìm)
        SetBP = BinProducts'ToBinProducts {(‚Ñì-suc ‚Ñìm)} {‚Ñìm} (SET ‚Ñìm) BinProducts'SET 

        SetProdR : Functor (SET (‚Ñìm) R√óC SET (‚Ñìm) ) (SET  (‚Ñìm))
        SetProdR = BinProductF {(‚Ñì-suc ‚Ñìm)} {‚Ñìm} (SET ‚Ñìm) SetBP

        SetProdB : Functor (SET ‚Ñìm B√óC SET ‚Ñìm) (SET ‚Ñìm)
        SetProdB = SetProdR ‚àòF ProdToRedundant (SET ‚Ñìm) (SET ‚Ñìm)

        ùì•BinProd : BinProducts ùì•
        ùì•BinProd = √óùìü {‚Ñì} {‚Ñì'} {C} {‚Ñìm}

        open Notation ùì• ùì•BinProd renaming (_√ó_ to _√óN_ ; _√óp_ to UHG ; _,p_ to ADF)
        open import Cubical.Categories.Limits.BinProduct.More

        -- theres probably a slicker way to define this.. I just don't know the combinators
        ‚®Çext : Functor (ùì• B√óC ùì•) ùì•√ó 
        ‚®Çext .F-ob (P , Q) = SetProdB ‚àòF (P √óF Q)
        ‚®Çext .F-hom (nt1 , nt2) = 
            SetProdB ‚àò ≥ natTrans 
                            (Œª{(s , t) ‚Üí nt1 .N-ob s , nt2 .N-ob t}) 
                            Œª{(f , g) ‚Üí Œª i ‚Üí (nt1 .N-hom f i) , (nt2 .N-hom g i) }
        ‚®Çext .F-id = makeNatTransPath refl
        ‚®Çext .F-seq f g = makeNatTransPath refl

        _‚®ÇExt_ : ob ùì• ‚Üí ob ùì• ‚Üí ob ùì•√ó 
        P ‚®ÇExt Q = ‚®Çext .F-ob (P , Q)
        
        module DayUP {P Q R : ob ùì•} where 
            -- some definitions

            {-
              Dom ==(lmap (diag x))=(rmap (diag x))==> Diag --inc--> Day' x = SetCoequalizer (lmap (diag x)) (rmap (diag x))
                                                            \            .
                                                              \          .
                                                              h   ‚àÉ! inducedHom
                                                                  \      .
                                                                    \    .
                                                                        C
            -}

            diag : ob C ‚Üí Bifunctor ((C B√óC C) ^op) (C B√óC C) (SET ‚Ñìm)
            diag = diagram {MC = SMC} P Q
            
            Dom : (x : ob C) ‚Üí Set ‚Ñìm
            Dom x = Œ£[ X ‚àà (ob C √ó ob C) ] 
                     Œ£[ Y ‚àà (ob C √ó ob C) ] 
                     Œ£[ (f , g) ‚àà ((C B√óC C) [ Y , X ]) ] 
                     ((diag x ‚üÖ (X , Y) ‚üÜb ) .fst)

            Diag : (x : ob C) ‚Üí Set ‚Ñìm
            Diag x = Œ£[ (y , z) ‚àà (ob C √ó ob C)] (fst (diag x ‚üÖ (y , z) , (y , z) ‚üÜb))

            Day' : (c : ob C) ‚Üí Coend (diag c)
            Day' = Day  {MC = SMC} P Q

            DayCoe : (c : ob C) ‚Üí hSet ‚Ñìm
            DayCoe c = Day' c .cowedge .nadir

            mapout : (nf : ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ] ) ‚Üí 
                (x : ob C) ‚Üí Diag x ‚Üí R .F-ob x .fst  
            mapout nf x ((y , z) , (x‚Üíy‚äóz , Py) , Qz) = R .F-hom x‚Üíy‚äóz (nf .N-ob (y , z) (Py , Qz))

            mapoutcoeq : (m : ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ])
                (x : ob C)
                (a : Dom x ) ‚Üí 
                mapout m x (lmap (diag x) a) 
                 ‚â°
                mapout m x (rmap (diag x) a)
            mapoutcoeq 
                record { N-ob = m ; N-hom = natfam } 
                x 
                ((y , z) , (y' , z') , (f , g) , (x‚Üíy'‚äóz' , Py) , Qz) = 
                    funExt‚Åª (R .F-seq _ _)  (m (y ,  z) (F-hom P (C . id) Py , F-hom Q (C . id) Qz)) 
                    ‚àô cong (Œª h ‚Üí  F-hom R x‚Üíy'‚äóz' h) 
                        (((cong‚ÇÇ (Œª h1 h2 ‚Üí F-hom R ((f ‚äó‚Çï g)) (m (_ ,  _ ) (h1 , h2))) (funExt‚Åª (P .F-id) _) ((funExt‚Åª (Q .F-id) _)) 
                        ‚àô funExt‚Åª (sym (natfam (f , g))) _) -- using naturality of the family
                        ‚àô funExt‚Åª (sym (R .F-id )) (m (_ , _ )(F-hom P f Py , F-hom Q g Qz))) 
                        ‚àô cong (Œª h ‚Üí R .F-hom h (m (_ , _) (F-hom P f Py , F-hom Q g Qz))) (sym (sms .tenstr .‚îÄ‚äó‚îÄ . F-id)))
                    ‚àô funExt‚Åª (sym (R .F-seq _ _)) (m (_ , _) (F-hom P f Py , F-hom Q g Qz)) 

            Œ∑‚â° : {x : ob C }
                {nf : ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ]}
                {other : SET ‚Ñìm [ (P ‚®Ç·¥∞ Q) .F-ob x , R .F-ob x ] }
                (prf : ((d : Diag x ) ‚Üí mapout nf x d ‚â° other (inc d)) ) ‚Üí 
                other ‚â° inducedHom 
                        (R .F-ob x .snd) 
                        (mapout nf x) 
                        (mapoutcoeq nf x)
            Œ∑‚â° {x}{nf} {other} prf =  
                uniqueness  
                    ((lmap (diag x))) 
                    ((rmap (diag x))) 
                    ((R .F-ob x .snd)) 
                    ((mapout nf x))  
                    ((mapoutcoeq nf x))
                    other 
                    prf

            fwd : ùì• [ P ‚®Ç·¥∞ Q , R ] ‚Üí ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ]
            fwd nt .N-ob (x , y) (Px , Qy) = nt .N-ob (x ‚äó y) (inc ((x , y) , (((C .id) , Px) , Qy)))
            fwd nt .N-hom {(x , y)}{(x' , y')} (f , g) = 
                funExt (Œª p ‚Üí cong (Œª h ‚Üí nt .N-ob ( x' ‚äó y') h)  
                    (sym (day-fact {MC = SMC} P Q {f = f}{g = g}{h = C .id}{p .fst}{p .snd}{f ‚äó‚Çï g} (sym (C .‚ãÜIdL _))) 
                    ‚àô day-ap‚Çò {MC = SMC} P Q (sym (C .‚ãÜIdR _))))
                ‚àô (funExt Œª{(Px , Qy) ‚Üí funExt‚Åª ((nt .N-hom (f ‚äó‚Çï g))) (inc ((x , y) , (C .id , Px) , Qy))}) 

            bkwd : ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ] ‚Üí ùì• [ P ‚®Ç·¥∞ Q , R ] 
            bkwd nf = natTrans Œ∑ Œ∑nat where 
                Œ∑ : N-ob-Type (P ‚®Ç·¥∞ Q) R 
                Œ∑ x = inducedHom 
                        (R .F-ob x .snd) 
                        (mapout nf x) 
                        (mapoutcoeq nf x)

                Œ∑nat : N-hom-Type (P ‚®Ç·¥∞ Q) R Œ∑ 
                Œ∑nat {x}{y} f = r‚àòt‚â°ind ‚àô sym (b‚àòl‚â°ind) where
                    open SetCoequalizer
                    --show that the diagram commutes since both paths are equal
                    -- because they yield the same inducedHom
                    r : (SET _)[ (P ‚®Ç·¥∞ Q) .F-ob x , R .F-ob y ] 
                    r = seq' (SET _) {(P ‚®Ç·¥∞ Q) .F-ob x}{(P ‚®Ç·¥∞ Q) .F-ob y}{R .F-ob y}
                        ((P ‚®Ç·¥∞ Q) .F-hom f) (Œ∑ y)

                    l : (SET _)[ (P ‚®Ç·¥∞ Q) .F-ob x , R .F-ob y ]
                    l = seq' (SET _){(P ‚®Ç·¥∞ Q) .F-ob x}{R .F-ob x}{R .F-ob y}
                        (Œ∑ x) (R .F-hom f)

                    td : Diag x ‚Üí DayCoe y .fst
                    td (x , Fxx) = Day-cowedge {MC = SMC} P Q f .œà x Fxx 

                    tcom : (a : Dom x) ‚Üí td ((lmap (diag x)) a) ‚â° td ((rmap (diag x)) a)
                    tcom (X , Y , g , Fxy) = funExt‚Åª (Day-cowedge {MC = SMC} P Q f .extranatural g) Fxy 


                    trcom : (a : Dom x) ‚Üí Œ∑ y (td (lmap (diag x) a)) ‚â° Œ∑ y (td (rmap (diag x) a))
                    trcom a = cong (Œª h ‚Üí Œ∑ y h) (tcom a)

                    ind : DayCoe x .fst ‚Üí R .F-ob y .fst 
                    ind = (inducedHom (R .F-ob y .snd) (Œ∑ y ‚àòS td) trcom)

                    r‚àòt‚â°ind : (Œ∑ y) ‚àòS ((P ‚®Ç·¥∞ Q) .F-hom f) ‚â° ind
                    r‚àòt‚â°ind = 
                        uniqueness 
                            ((lmap (diag x))) 
                            ((rmap (diag x))) 
                            (R .F-ob y .snd) 
                            (Œ∑ y ‚àòS td)
                            trcom 
                            r 
                            Œª _ ‚Üí refl

                    b‚àòl‚â°ind : ((R .F-hom f) ‚àòS (Œ∑ x)) ‚â° ind
                    b‚àòl‚â°ind = 
                        uniqueness
                            ((lmap (diag x))) 
                            ((rmap (diag x))) 
                            (R .F-ob y .snd) 
                            ((Œ∑ y ‚àòS td)) 
                            trcom 
                            l 
                            Œª _ ‚Üí funExt‚Åª (R .F-seq _ _) _

            ‚®ÇUP :  Iso (ùì• [ P ‚®Ç·¥∞ Q , R ]) (ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ]) 
            ‚®ÇUP = iso 
                    fwd 
                    bkwd 
                    (Œª b ‚Üí makeNatTransPath (funExt Œª{(x , y) ‚Üí funExt Œª{(Px , Qy) ‚Üí funExt‚Åª (R .F-id) _ }}) )
                    (Œª b ‚Üí makeNatTransPath (funExt Œª x ‚Üí 
                                -- show the components are equal by showing they are equal maps on diagrams
                                sym (Œ∑‚â°  Œª {((y , z) , (x‚Üíy‚äóz , Py) , Qz) ‚Üí 
                                    funExt‚Åª (sym (b .N-hom _)) _ 
                                        ‚àô cong (Œª h ‚Üí b .N-ob x h) (day-ap‚Çò {MC = SMC} P Q (C .‚ãÜIdR _))} ))) 
 
        {-
        alternative def using right adjoint instead of iso of homsets
        open import Cubical.Categories.Adjoint.2Var
        sep : Type _
        sep = RightAdjointL {! Functor‚ÜíBifunctor  !} -}



        -- TODO compare .. just a family of sets vs partial nat trans!
        -- which is correct!?
        -- remember, the setup CBPV is different
        {- 
                    _‚ä∏_ : ob ùí± ‚Üí ob ùí± ‚Üí ob ùí±
            -- todo make a Set^Inj
            _‚ä∏_ A B .F-ob X = (‚àÄ (Y : ob Inj) ‚Üí (SET ‚ÑìS) [ A .F-ob Y , B .F-ob (_‚®Ç_ .F-ob (X , Y)) ]) , isSetŒ†  Œª _ ‚Üí (SET ‚ÑìS) .isSetHom
            _‚ä∏_ A B .F-hom {X} {Y} f FX Z AZ = B .F-hom (_‚®Ç_ .F-hom (f , (Inj .id))) (FX Z AZ)
            _‚ä∏_ A B .F-id = {!   !}
                --funExt Œª e ‚Üí funExt Œª x ‚Üí funExt Œª Ax ‚Üí cong (Œª h ‚Üí B .F-hom h (e x Ax)) ((_‚®Ç_ .F-id)) ‚àô funExt‚Åª (B .F-id) _
            _‚ä∏_ A B .F-seq = {!   !}
        -} 


        {- 
          _‚àò ≥_ : ‚àÄ (K : Functor C D) ‚Üí {G H : Functor B C} (Œ≤ : NatTrans G H)
       ‚Üí NatTrans (K ‚àòF G) (K ‚àòF H)
        -}
        open import src.Data.Semicartesian
        ‚®Çc^op = ‚îÄ‚äó‚îÄ^op where 
            open StrictMonCategory (SMC ^opMon) renaming (‚îÄ‚äó‚îÄ to ‚îÄ‚äó‚îÄ^op)
        open import Cubical.Categories.Instances.Functors.More
        
        _‚®Çc- : Functor (C ^op) (FUNCTOR (C ^op) (C ^op))
        _‚®Çc- = curryF (C ^op) (C ^op) {Œì = (C ^op)} .F-ob ‚®Çc^op

        _‚¶Ö_‚äó-‚¶Ü : ob ùì• ‚Üí ob C ‚Üí ob ùì•
        _‚¶Ö_‚äó-‚¶Ü P x = P ‚àòF (_‚®Çc- .F-ob x)

        private 
            test : (x y : ob C) ‚Üí (R : ob ùì•) ‚Üí (R ‚¶Ö x ‚äó-‚¶Ü) .F-ob y ‚â° R .F-ob (x ‚äó y)
            test x y R = refl
            
        partialAp : {x y : ob C}(P : ob ùì•)(f : (C ^op) [ x , y ]) ‚Üí ùì• [ P ‚¶Ö x ‚äó-‚¶Ü , P ‚¶Ö y ‚äó-‚¶Ü ]
        partialAp {x}{y} P f = P ‚àò ≥ (_‚®Çc- .F-hom f)

        partialApId : {x : ob C}(P : ob ùì•) ‚Üí 
            partialAp P (C .id) ‚â° idTrans (P ‚¶Ö x ‚äó-‚¶Ü)
        partialApId P = 
            (Œª i ‚Üí P ‚àò ≥ (_‚®Çc- .F-id) i) 
            ‚àô makeNatTransPath (funExt Œª x ‚Üí P .F-id)
        
        partialSeq : {x y z : ob (C ^op)}(P : ob ùì•)(f : (C ^op) [ x , y ])(g : (C ^op) [ y , z ]) ‚Üí 
            partialAp P (f ‚ãÜ‚ü® C ^op ‚ü© g) ‚â° partialAp P f ‚ãÜ‚ü® ùì• ‚ü© partialAp P g
        partialSeq {x}{y}{z} P f g = 
            (Œª i ‚Üí P ‚àò ≥ (_‚®Çc- .F-seq f g) i) 
            ‚àô makeNatTransPath (funExt Œª w ‚Üí (P .F-seq _ _))
          

        _‚ä∏_ : ob ùì• ‚Üí ob ùì• ‚Üí ob ùì• 
        (P ‚ä∏ Q) .F-ob x = ùì• [ P , Q ‚¶Ö x ‚äó-‚¶Ü ] , ùì• .isSetHom
        (P ‚ä∏ Q) .F-hom f nt = nt ‚ãÜ‚ü® ùì• ‚ü© partialAp Q f
        (P ‚ä∏ Q) .F-id = funExt Œª nt ‚Üí cong (Œª h ‚Üí seqTrans nt h) (partialApId Q) ‚àô ùì• .‚ãÜIdR nt
        (P ‚ä∏ Q) .F-seq {x}{y}f g = funExt Œª nt ‚Üí 
            cong (Œª h ‚Üí seqTrans nt h) (partialSeq Q f g) 
            ‚àô sym (ùì• .‚ãÜAssoc nt (partialAp Q f) (partialAp Q g))



        module SepUP {P Q R : ob ùì•} where 
            open DayUP

            left : ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ] ‚Üí ùì• [ P , Q ‚ä∏ R ] 
            left nt = natTrans Œ∑ Œ∑com where 
                Œ∑ : N-ob-Type P (Q ‚ä∏ R)
                Œ∑ x Px = natTrans Œ∑' Œ∑'com where 
                    Œ∑' : N-ob-Type Q (R ‚¶Ö x ‚äó-‚¶Ü) 
                    Œ∑' y Qy = nt .N-ob (x , y) (Px , Qy)

                    Œ∑'com : N-hom-Type Q (R ‚¶Ö x ‚äó-‚¶Ü) Œ∑'
                    Œ∑'com {y}{z} z‚Üíy = funExt Œª Qy ‚Üí 
                        cong (Œª h ‚Üí nt .N-ob (x , z) h ) (‚â°-√ó (funExt‚Åª (sym (P .F-id)) Px) refl)
                        -- use naturality of nt
                        ‚àô funExt‚Åª (nt .N-hom (C .id , z‚Üíy)) _
                        
                Œ∑com : N-hom-Type P (Q ‚ä∏ R) Œ∑
                Œ∑com {x}{y} y‚Üíx = funExt Œª Px ‚Üí makeNatTransPath (funExt Œª z ‚Üí funExt Œª Qz ‚Üí 
                    cong (Œª h ‚Üí nt .N-ob (y , z) h ) (‚â°-√ó  refl (funExt‚Åª (sym (Q .F-id)) Qz)) 
                    ‚àô funExt‚Åª (nt .N-hom (y‚Üíx , C .id)) _)

            eval : ùì•√ó [ (Q ‚ä∏ R)  ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ] 
            eval = natTrans Œ∑ Œ∑com where 
                Œ∑ : N-ob-Type ((Q ‚ä∏ R) ‚®ÇExt Q) (R ‚àòF (‚®Çc ^opF)) 
                Œ∑ (x , y) (f , q) = f .N-ob y q

                Œ∑com : N-hom-Type ((Q ‚ä∏ R) ‚®ÇExt Q) (R ‚àòF (‚®Çc ^opF)) Œ∑
                Œ∑com {x}{y}(f‚ÇÅ , f‚ÇÇ) = funExt goal where 

                    goal : ((q‚ä∏r , q) : fst (F-ob ((Q ‚ä∏ R) ‚®ÇExt Q) x)) ‚Üí 
                          F-hom R (‚®Çc .F-hom (f‚ÇÅ , C .id))(q‚ä∏r .N-ob (snd y) (F-hom Q f‚ÇÇ q)) 
                        ‚â° F-hom R (‚®Çc .F-hom (f‚ÇÅ , f‚ÇÇ))   (q‚ä∏r .N-ob (snd x) q)
                    goal (q‚ä∏r , q) = 
                        -- using naturality of q‚ä∏r
                        cong (Œª h ‚Üí R .F-hom _ h) (funExt‚Åª (q‚ä∏r .N-hom f‚ÇÇ) q)
                        -- collapse sequence of R.hom 
                        ‚àô funExt‚Åª (sym (R .F-seq _ _ ))_ 
                        ‚àô cong (Œª h ‚Üí R .F-hom h _) 
                            (sym (‚®Çc .F-seq _ _) 
                            ‚àô cong (Œª h ‚Üí ‚®Çc .F-hom h) (‚â°-√ó (C .‚ãÜIdR _) (C .‚ãÜIdL _)))
                            
            right : ùì• [ P , Q ‚ä∏ R ] ‚Üí ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ] 
            right nt = ‚®Çext .F-hom (nt , ùì• .id) ‚ãÜ‚ü® ùì•√ó ‚ü© eval

            -- easier to prove this isomorphism and then use the universal property of the tensor
            ‚ä∏UP' : Iso (ùì•√ó [ P ‚®ÇExt Q , R ‚àòF (‚®Çc ^opF) ]) (ùì• [ P , Q ‚ä∏ R ]) 
            ‚ä∏UP' = iso 
                    left 
                    right 
                    (Œª _ ‚Üí makeNatTransPath (funExt Œª x ‚Üí funExt Œª Px ‚Üí makeNatTransPath (funExt Œª y ‚Üí funExt Œª Qy ‚Üí refl)))
                    (Œª _ ‚Üí makeNatTransPath (funExt Œª (x , y) ‚Üí funExt Œª (Px , Qy) ‚Üí refl))

            ‚ä∏UP : Iso (ùì• [ P ‚®Ç·¥∞ Q , R ]) (ùì• [ P , Q ‚ä∏ R ]) 
            ‚ä∏UP = compIso (‚®ÇUP {P}{Q}{R}) ‚ä∏UP'

{-  meh
        open import Cubical.Categories.Adjoint
        open AdjointUniqeUpToNatIso 
        open NaturalBijection
        open _‚ä£_

        ‚®ÇF : ob ùì• ‚Üí Functor ùì• ùì• 
        ‚®ÇF P = (curryF (PshC SMC) (PshC SMC){Œì = PshC SMC} .F-ob 
                (swapArgs (PshC SMC) (PshC SMC) {Œì = PshC SMC}.F-ob (Day-Functor SMC))) 
                    .F-ob P
        
        ‚ä∏F : ob ùì• ‚Üí Functor ùì• ùì• 
        ‚ä∏F P .F-ob Q = P ‚ä∏ Q
        ‚ä∏F P .F-hom f .N-ob c p = p ‚ãÜ‚ü® ùì• ‚ü© {!   !}
        ‚ä∏F P .F-hom f .N-hom = {!   !}
        ‚ä∏F P .F-id = {!   !}
        ‚ä∏F P .F-seq = {!   !}
        
        --swapArgs _ _ .F-ob (Day-Functor SMC ) 
        open SepUP
        ‚ä∏Adj : {Q : ob ùì• } ‚Üí ‚®ÇF Q ‚ä£ ‚ä∏F Q
        ‚ä∏Adj {Q} .adjIso {P}{R} = ‚ä∏UP {P}{Q}{R} 
        ‚ä∏Adj .adjNatInD f k = 
            makeNatTransPath (funExt Œª x ‚Üí funExt Œª Px ‚Üí 
                makeNatTransPath (funExt Œª y ‚Üí funExt Œª Qy ‚Üí {!   !})) 
        ‚ä∏Adj .adjNatInC = {!   !} 
-}
 